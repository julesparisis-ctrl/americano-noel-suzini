
<!DOCTYPE html>
<html lang="fr">
<head>
 <meta charset="UTF-8" />
 <title>Jury – Beach-Noël</title>
 <meta name="viewport" content="width=device-width, initial-scale=1.0" />
 <style>
   body {
     font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
     margin: 0;
     padding: 0;
     background: #f5f5f5;
   }
   header {
     background: #b71c1c;
     color: #fff;
     padding: 10px 12px;
     text-align: center;
     font-weight: bold;
   }
   .container {
     padding: 10px;
     max-width: 900px;
     margin: 0 auto;
   }

   /* Tabs */
   .tabs {
     display: flex;
     gap: 6px;
     margin-bottom: 10px;
     flex-wrap: wrap;
   }
   .tab-button {
     flex: 1;
     padding: 8px;
     border: none;
     background: #e0e0e0;
     cursor: pointer;
     font-size: 14px;
     border-radius: 4px;
   }
   .tab-button.active {
     background: #b71c1c;
     color: #fff;
     font-weight: 600;
   }
   .tab-content {
     display: none;
     background: #fff;
     border-radius: 6px;
     padding: 10px;
     box-shadow: 0 1px 3px rgba(0,0,0,0.15);
   }
   .tab-content.active {
     display: block;
   }

   h2 {
     font-size: 18px;
     margin-top: 0;
   }

   .note {
     font-size: 12px;
     color: #777;
     margin-top: 4px;
     margin-bottom: 8px;
   }

   .btn {
     padding: 6px 10px;
     border: none;
     border-radius: 4px;
     cursor: pointer;
     font-size: 14px;
     margin-right: 6px;
   }
   .btn-primary {
     background: #b71c1c;
     color: #fff;
   }
   .btn-secondary {
     background: #eeeeee;
     color: #333;
   }
   .btn-danger {
     background: #c62828;
     color: #fff;
   }
   .btn[disabled] {
     opacity: 0.6;
     cursor: not-allowed;
   }

   table {
     width: 100%;
     border-collapse: collapse;
     font-size: 13px;
     margin-top: 6px;
   }
   th, td {
     border: 1px solid #ddd;
     padding: 4px 6px;
     text-align: left;
   }
   th {
     background: #f0f0f0;
   }
   td input[type="number"] {
     width: 60px;
     padding: 3px;
     font-size: 13px;
     text-align: center;
   }

   .status-chip {
     display: inline-block;
     padding: 3px 8px;
     border-radius: 10px;
     font-size: 11px;
     margin-left: 6px;
   }
   .status-provisional {
     background: #fff3cd;
     color: #856404;
   }
   .status-final {
     background: #c8e6c9;
     color: #256029;
   }

   .rank-badge { font-weight: bold; }
   .rank-top { background: #fff8e1; }
 </style>
</head>
<body>
<header>
 Jury – Classement Beach-Noël – Beach Tennis Suzini
</header>

<div class="container">
 <!-- Onglets -->
 <div class="tabs">
   <button class="tab-button active" data-tab="notesTab">Notes</button>
   <button class="tab-button" data-tab="classementTab">Classement</button>
 </div>

 <!-- Onglet Notes -->
 <div id="notesTab" class="tab-content active">
   <h2>Notes Beach-Noël
     <span id="statusChipNotes" class="status-chip status-provisional">Classement provisoire</span>
   </h2>
   <p class="note">
     Le jury attribue une note entre 1 et 20 à chaque joueur.<br>
     À chaque enregistrement, les bonus provisoires sont recalculés selon le classement courant.<br>
     En cas d’égalité, les joueurs ont le même rang et le même bonus.<br>
     Une fois le classement validé, les notes ne sont plus modifiables.
   </p>

   <div style="margin-bottom:8px;">
     <button id="saveNotesBtn" class="btn btn-primary">Enregistrer les notes</button>
     <button id="validateClassementBtn" class="btn btn-secondary">Valider définitivement le classement</button>
     <button id="resetNotesBtn" class="btn btn-danger" disabled>Remise à zéro des notes</button>
   </div>

   <div id="notesTableContainer"></div>
 </div>

 <!-- Onglet Classement -->
 <div id="classementTab" class="tab-content">
   <h2>Classement Beach-Noël
     <span id="statusChipClassement" class="status-chip status-provisional">Classement provisoire</span>
   </h2>
   <p class="note">
     Classement basé sur la note Beach-Noël + bonus Beach-Noël.<br>
     Bonus : 1er +30, 2e +20, 3e +15, 4e +10, 5e +7, 6e +4, 7e +2, 8e +1.
   </p>
   <div id="classementTableContainer"></div>
 </div>
</div>

<script type="module">
 import { initializeApp } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-app.js";
 import { getAnalytics } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-analytics.js";
 import {
   getFirestore,
   collection,
   doc,
   onSnapshot,
   query,
   orderBy,
   updateDoc,
   getDoc,
   setDoc
 } from "https://www.gstatic.com/firebasejs/12.6.0/firebase-firestore.js";

 const firebaseConfig = {
   apiKey: "AIzaSyB8BS8_Z7-vUVkVZcHhWxUzP62KkB1I4M4",
   authDomain: "americano-noel-suzini.firebaseapp.com",
   projectId: "americano-noel-suzini",
   storageBucket: "americano-noel-suzini.firebasestorage.app",
   messagingSenderId: "925339847006",
   appId: "1:925339847006:web:ce952f6db6fc5ded7527cf",
   measurementId: "G-LG0BQ9V11J"
 };

 const app = initializeApp(firebaseConfig);
 getAnalytics(app);
 const db = getFirestore(app);

 // === Onglets ===
 const tabButtons = document.querySelectorAll(".tab-button");
 const tabContents = document.querySelectorAll(".tab-content");
 tabButtons.forEach(btn => {
   btn.addEventListener("click", () => {
     const target = btn.getAttribute("data-tab");
     tabButtons.forEach(b => b.classList.remove("active"));
     tabContents.forEach(c => c.classList.remove("active"));
     btn.classList.add("active");
     document.getElementById(target).classList.add("active");
   });
 });

 // === DOM ===
 const notesTableContainer = document.getElementById("notesTableContainer");
 const classementTableContainer = document.getElementById("classementTableContainer");
 const saveNotesBtn = document.getElementById("saveNotesBtn");
 const validateClassementBtn = document.getElementById("validateClassementBtn");
 const resetNotesBtn = document.getElementById("resetNotesBtn");
 const statusChipNotes = document.getElementById("statusChipNotes");
 const statusChipClassement = document.getElementById("statusChipClassement");

 // === Firestore refs ===
 const playersCol = collection(db, "players");
 const settingsDocRef = doc(db, "settings", "beachNoel");

 let playersCache = [];
 let classementValidated = false;

 async function initSettings() {
   const snap = await getDoc(settingsDocRef);
   if (!snap.exists()) {
     await setDoc(settingsDocRef, { validated: false, validatedAt: null });
   }
 }
 await initSettings();

 onSnapshot(settingsDocRef, (snap) => {
   if (!snap.exists()) return;
   const data = snap.data();
   classementValidated = !!data.validated;
   updateStatusChips();
   updateButtonsState();
 });

 function updateStatusChips() {
   if (classementValidated) {
     statusChipNotes.textContent = "Classement final (clôturé)";
     statusChipNotes.className = "status-chip status-final";
     statusChipClassement.textContent = "Classement final (clôturé)";
     statusChipClassement.className = "status-chip status-final";
   } else {
     statusChipNotes.textContent = "Classement provisoire";
     statusChipNotes.className = "status-chip status-provisional";
     statusChipClassement.textContent = "Classement provisoire";
     statusChipClassement.className = "status-chip status-provisional";
   }
 }

 function updateButtonsState() {
   if (classementValidated) {
     saveNotesBtn.disabled = true;
     validateClassementBtn.disabled = true;
     resetNotesBtn.disabled = false;
     renderNotesTable(playersCache);
   } else {
     saveNotesBtn.disabled = false;
     validateClassementBtn.disabled = false;
     resetNotesBtn.disabled = true;
     renderNotesTable(playersCache);
   }
 }

 const playersQuery = query(playersCol, orderBy("createdAt", "asc"));
 onSnapshot(playersQuery, (snapshot) => {
   const players = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));
   playersCache = players;
   renderNotesTable(players);
   renderClassementTable(players);
 });

 function getBonusForRank(rank) {
   switch (rank) {
     case 1: return 30;
     case 2: return 20;
     case 3: return 15;
     case 4: return 10;
     case 5: return 7;
     case 6: return 4;
     case 7: return 2;
     case 8: return 1;
     default: return 0;
   }
 }

 // === Rangs avec égalités (ranking "compétition": 1,1,3,4...) ===
 // keyGetter: renvoie la valeur sur laquelle on teste l’égalité (note ou pointsNoel)
 function assignRanksWithTies(list, keyGetter) {
   let prevVal = null;
   let currentRank = 0;
   for (let i = 0; i < list.length; i++) {
     const v = keyGetter(list[i]);
     if (i === 0) {
       currentRank = 1;
     } else if (v !== prevVal) {
       currentRank = i + 1;
     }
     list[i].rank = currentRank;
     prevVal = v;
   }
   return list;
 }

 function renderNotesTable(players) {
   if (!players.length) {
     notesTableContainer.innerHTML = "<p>Aucun joueur trouvé.</p>";
     return;
   }

   const sorted = [...players].sort((a, b) =>
     (a.name || "").localeCompare(b.name || "", "fr", { sensitivity: "base" })
   );

   let html = "<table><thead><tr>";
   html += "<th>Nom</th>";
   html += "<th>Note Beach-Noël<br><span style='font-weight:normal'>(1 à 20)</span></th>";
   html += "</tr></thead><tbody>";

   sorted.forEach(p => {
     // ✅ champs corrigés : beachNoelNote
     const note = (typeof p.beachNoelNote === "number") ? p.beachNoelNote : "";
     html += `<tr data-player-id="${p.id}">
       <td>${p.name || ""}</td>
       <td><input type="number" min="1" max="20" value="${note}" ${classementValidated ? "disabled" : ""}></td>
     </tr>`;
   });

   html += "</tbody></table>";
   notesTableContainer.innerHTML = html;
 }

 function renderClassementTable(players) {
   if (!players.length) {
     classementTableContainer.innerHTML = "<p>Aucun joueur trouvé.</p>";
     return;
   }

   // ✅ champs corrigés + affichage des rangs avec égalités sur pointsNoel
   const enriched = players.map(p => {
     const note = typeof p.beachNoelNote === "number" ? p.beachNoelNote : 0;
     const bonus = typeof p.beachNoelBonus === "number" ? p.beachNoelBonus : 0;
     const pointsNoel = typeof p.pointsNoel === "number" ? p.pointsNoel : (note + bonus);
     return { id: p.id, name: p.name || "", note, bonus, pointsNoel };
   });

   enriched.sort((a, b) => {
     if (b.pointsNoel !== a.pointsNoel) return b.pointsNoel - a.pointsNoel;
     if (b.note !== a.note) return b.note - a.note;
     return a.name.localeCompare(b.name, "fr", { sensitivity: "base" });
   });

   assignRanksWithTies(enriched, p => p.pointsNoel);

   let html = "<table><thead><tr>";
   html += "<th>#</th><th>Nom</th><th>Note Beach-Noël</th><th>Bonus Beach-Noël</th><th>Points Beach-Noël</th>";
   html += "</tr></thead><tbody>";

   enriched.forEach((p) => {
     const rankClass = p.rank <= 8 ? "rank-top" : "";
     const rankBadge = p.rank <= 8 ? `<span class="rank-badge">${p.rank}</span>` : p.rank;
     html += `<tr class="${rankClass}">
       <td>${rankBadge}</td>
       <td>${p.name}</td>
       <td>${p.note}</td>
       <td>${p.bonus}</td>
       <td>${p.pointsNoel}</td>
     </tr>`;
   });

   html += "</tbody></table>";
   classementTableContainer.innerHTML = html;
 }

 // === Enregistrer notes + recalcul bonus provisoire (avec égalités) ===
 saveNotesBtn.addEventListener("click", async () => {
   if (classementValidated) return;

   const rows = notesTableContainer.querySelectorAll("tbody tr");
   if (!rows.length) {
     alert("Aucun joueur à noter.");
     return;
   }

   // 1) Lire notes saisies
   const notesByPlayerId = new Map();
   rows.forEach(row => {
     const playerId = row.getAttribute("data-player-id");
     const input = row.querySelector("input[type='number']");
     let val = input.value.trim();
     if (val === "") {
       notesByPlayerId.set(playerId, null);
     } else {
       let num = Number(val);
       if (Number.isNaN(num)) num = null;
       if (num !== null) {
         if (num < 1) num = 1;
         if (num > 20) num = 20;
       }
       input.value = num ?? "";
       notesByPlayerId.set(playerId, num);
     }
   });

   // 2) Classement provisoire par NOTE (desc), avec égalités => même rang
   const scoringList = playersCache.map(p => {
     const note = notesByPlayerId.has(p.id)
       ? (notesByPlayerId.get(p.id) ?? 0)
       : (typeof p.beachNoelNote === "number" ? p.beachNoelNote : 0); // ✅ champ corrigé
     return { id: p.id, name: p.name || "", note };
   });

   scoringList.sort((a, b) => {
     if (b.note !== a.note) return b.note - a.note;
     return a.name.localeCompare(b.name, "fr", { sensitivity: "base" });
   });

   assignRanksWithTies(scoringList, p => p.note);

   // 3) Bonus : même rang => même bonus (si note > 0)
   const bonusById = new Map();
   scoringList.forEach(p => {
     const bonus = (p.note > 0) ? getBonusForRank(p.rank) : 0;
     bonusById.set(p.id, bonus);
   });

   // 4) Update Firestore
   try {
     for (const p of playersCache) {
       const noteRaw = notesByPlayerId.has(p.id)
         ? notesByPlayerId.get(p.id)
         : (typeof p.beachNoelNote === "number" ? p.beachNoelNote : null); // ✅ champ corrigé

       const note = noteRaw ?? 0;
       const bonus = bonusById.get(p.id) ?? 0;
       const pointsNoel = note + bonus;

       await updateDoc(doc(db, "players", p.id), {
         beachNoelNote: noteRaw,     // null si non noté
         beachNoelBonus: bonus,
         pointsNoel: pointsNoel
       });
     }

     alert("Notes enregistrées et bonus provisoires recalculés (avec égalités).");
   } catch (err) {
     console.error("Erreur lors de l'enregistrement des notes :", err);
     alert("Erreur lors de l'enregistrement des notes.");
   }
 });

 validateClassementBtn.addEventListener("click", async () => {
   if (classementValidated) return;

   if (!confirm("Valider définitivement le classement Beach-Noël ?\nLes notes ne seront plus modifiables (sauf remise à zéro).")) {
     return;
   }

   try {
     await setDoc(settingsDocRef, { validated: true, validatedAt: Date.now() }, { merge: true });
     alert("Classement Beach-Noël validé définitivement.");
   } catch (err) {
     console.error("Erreur lors de la validation du classement :", err);
     alert("Erreur lors de la validation du classement.");
   }
 });

 resetNotesBtn.addEventListener("click", async () => {
   if (!classementValidated) return;

   if (!confirm("Remettre à zéro toutes les notes et bonus Beach-Noël ?\nCela supprimera le classement actuel et repassera en mode brouillon.")) {
     return;
   }

   try {
     for (const p of playersCache) {
       await updateDoc(doc(db, "players", p.id), {
         beachNoelNote: null,
         beachNoelBonus: 0,
         pointsNoel: 0
       });
     }

     await setDoc(settingsDocRef, { validated: false, validatedAt: null }, { merge: true });
     alert("Toutes les notes ont été remises à zéro. Vous pouvez ressaisir un nouveau classement.");
   } catch (err) {
     console.error("Erreur lors de la remise à zéro des notes :", err);
     alert("Erreur lors de la remise à zéro des notes.");
   }
 });
</script>
</body>
</html>
